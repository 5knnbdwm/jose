var Vt=Object.defineProperty;var tt=(e,t)=>{for(var r in t)Vt(e,r,{get:t[r],enumerable:!0})};var f=crypto;function _(e){try{return e!=null&&typeof e.extractable=="boolean"&&typeof e.algorithm.name=="string"&&typeof e.type=="string"}catch(t){return!1}}var zt=async(e,t)=>{let r=`SHA-${e.slice(-3)}`;return new Uint8Array(await f.subtle.digest(r,t))},ce=zt;var w=new TextEncoder,K=new TextDecoder,Ke=2**32;function P(...e){let t=e.reduce((o,{length:a})=>o+a,0),r=new Uint8Array(t),n=0;return e.forEach(o=>{r.set(o,n),n+=o.length}),r}function rt(e,t){return P(w.encode(e),new Uint8Array([0]),t)}function Be(e,t,r){if(t<0||t>=Ke)throw new RangeError(`value must be >= 0 and <= ${Ke-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,t&255],r)}function ve(e){let t=Math.floor(e/Ke),r=e%Ke,n=new Uint8Array(8);return Be(n,t,0),Be(n,r,4),n}function Ce(e){let t=new Uint8Array(4);return Be(t,e),t}function He(e){return P(Ce(e.length),e)}async function nt(e,t,r){let n=Math.ceil((t>>3)/32),o;for(let a=1;a<=n;a++){let i=new Uint8Array(4+e.length+r.length);i.set(Ce(a)),i.set(e,4),i.set(r,4+e.length),o?o=P(o,await ce("sha256",i)):o=await ce("sha256",i)}return o=o.slice(0,t>>3),o}var de=e=>{let t=e;typeof t=="string"&&(t=w.encode(t));let r=32768,n=[];for(let o=0;o<t.length;o+=r)n.push(String.fromCharCode.apply(null,t.subarray(o,o+r)));return btoa(n.join(""))},E=e=>de(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),Le=e=>new Uint8Array(atob(e).split("").map(t=>t.charCodeAt(0))),b=e=>{let t=e;t instanceof Uint8Array&&(t=K.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return Le(t)}catch(r){throw new TypeError("The input to be decoded is not correctly encoded.")}};var at={};tt(at,{JOSEAlgNotAllowed:()=>F,JOSEError:()=>H,JOSENotSupported:()=>l,JWEDecryptionFailed:()=>k,JWEInvalid:()=>u,JWKInvalid:()=>xe,JWKSInvalid:()=>V,JWKSMultipleMatchingKeys:()=>Pe,JWKSNoMatchingKey:()=>Q,JWKSTimeout:()=>We,JWSInvalid:()=>m,JWSSignatureVerificationFailed:()=>j,JWTClaimValidationFailed:()=>J,JWTExpired:()=>pe,JWTInvalid:()=>C});var H=class extends Error{constructor(t){var r;super(t);this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,(r=Error.captureStackTrace)===null||r===void 0||r.call(Error,this,this.constructor)}static get code(){return"ERR_JOSE_GENERIC"}},J=class extends H{constructor(t,r="unspecified",n="unspecified"){super(t);this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=r,this.reason=n}static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}},pe=class extends H{constructor(t,r="unspecified",n="unspecified"){super(t);this.code="ERR_JWT_EXPIRED",this.claim=r,this.reason=n}static get code(){return"ERR_JWT_EXPIRED"}},F=class extends H{constructor(){super(...arguments);this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}},l=class extends H{constructor(){super(...arguments);this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}},k=class extends H{constructor(){super(...arguments);this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}},u=class extends H{constructor(){super(...arguments);this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}},m=class extends H{constructor(){super(...arguments);this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}},C=class extends H{constructor(){super(...arguments);this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}},xe=class extends H{constructor(){super(...arguments);this.code="ERR_JWK_INVALID"}static get code(){return"ERR_JWK_INVALID"}},V=class extends H{constructor(){super(...arguments);this.code="ERR_JWKS_INVALID"}static get code(){return"ERR_JWKS_INVALID"}},Q=class extends H{constructor(){super(...arguments);this.code="ERR_JWKS_NO_MATCHING_KEY",this.message="no applicable key found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_NO_MATCHING_KEY"}},Pe=class extends H{constructor(){super(...arguments);this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS",this.message="multiple matching keys found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_MULTIPLE_MATCHING_KEYS"}},We=class extends H{constructor(){super(...arguments);this.code="ERR_JWKS_TIMEOUT",this.message="request timed out"}static get code(){return"ERR_JWKS_TIMEOUT"}},j=class extends H{constructor(){super(...arguments);this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}};var B=f.getRandomValues.bind(f);function $e(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new l(`Unsupported JWE Algorithm: ${e}`)}}var Je=e=>B(new Uint8Array($e(e)>>3));var Yt=(e,t)=>{if(t.length<<3!==$e(e))throw new u("Invalid Initialization Vector length")},Te=Yt;var Xt=(e,t)=>{if(e.length<<3!==t)throw new u("Invalid Content Encryption Key length")},ee=Xt;var qt=(e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");let r=e.length,n=0,o=-1;for(;++o<r;)n|=e[o]^t[o];return n===0},it=qt;function D(){return typeof WebSocketPair=="function"}function T(){try{return process.versions.node!==void 0}catch(e){return!1}}function W(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function R(e,t){return e.name===t}function Ie(e){return parseInt(e.name.slice(4),10)}function Zt(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function st(e,t){if(t.length&&!t.some(r=>e.usages.includes(r))){let r="CryptoKey does not support this operation, its usages must include ";if(t.length>2){let n=t.pop();r+=`one of ${t.join(", ")}, or ${n}.`}else t.length===2?r+=`one of ${t[0]} or ${t[1]}.`:r+=`${t[0]}.`;throw new TypeError(r)}}function ct(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!R(e.algorithm,"HMAC"))throw W("HMAC");let n=parseInt(t.slice(2),10);if(Ie(e.algorithm.hash)!==n)throw W(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!R(e.algorithm,"RSASSA-PKCS1-v1_5"))throw W("RSASSA-PKCS1-v1_5");let n=parseInt(t.slice(2),10);if(Ie(e.algorithm.hash)!==n)throw W(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!R(e.algorithm,"RSA-PSS"))throw W("RSA-PSS");let n=parseInt(t.slice(2),10);if(Ie(e.algorithm.hash)!==n)throw W(`SHA-${n}`,"algorithm.hash");break}case(T()&&"EdDSA"):{if(e.algorithm.name!=="NODE-ED25519"&&e.algorithm.name!=="NODE-ED448")throw W("NODE-ED25519 or NODE-ED448");break}case(D()&&"EdDSA"):{if(!R(e.algorithm,"NODE-ED25519"))throw W("NODE-ED25519");break}case"ES256":case"ES384":case"ES512":{if(!R(e.algorithm,"ECDSA"))throw W("ECDSA");let n=Zt(t);if(e.algorithm.namedCurve!==n)throw W(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}st(e,r)}function I(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!R(e.algorithm,"AES-GCM"))throw W("AES-GCM");let n=parseInt(t.slice(1,4),10);if(e.algorithm.length!==n)throw W(n,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!R(e.algorithm,"AES-KW"))throw W("AES-KW");let n=parseInt(t.slice(1,4),10);if(e.algorithm.length!==n)throw W(n,"algorithm.length");break}case"ECDH-ES":if(!R(e.algorithm,"ECDH"))throw W("ECDH");break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!R(e.algorithm,"PBKDF2"))throw W("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!R(e.algorithm,"RSA-OAEP"))throw W("RSA-OAEP");let n=parseInt(t.slice(9),10)||1;if(Ie(e.algorithm.hash)!==n)throw W(`SHA-${n}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}st(e,r)}var S=(e,...t)=>{let r="Key must be ";if(t.length>2){let n=t.pop();r+=`one of type ${t.join(", ")}, or ${n}.`}else t.length===2?r+=`one of type ${t[0]} or ${t[1]}.`:r+=`of type ${t[0]}.`;return e==null?r+=` Received ${e}`:typeof e=="function"&&e.name?r+=` Received function ${e.name}`:typeof e=="object"&&e!=null&&e.constructor&&e.constructor.name&&(r+=` Received an instance of ${e.constructor.name}`),r};var Ge=e=>_(e),h=["CryptoKey"];async function Qt(e,t,r,n,o,a){if(!(t instanceof Uint8Array))throw new TypeError(S(t,"Uint8Array"));let i=parseInt(e.slice(1,4),10),s=await f.subtle.importKey("raw",t.subarray(i>>3),"AES-CBC",!1,["decrypt"]),d=await f.subtle.importKey("raw",t.subarray(0,i>>3),{hash:`SHA-${i<<1}`,name:"HMAC"},!1,["sign"]),c=P(a,n,r,ve(a.length<<3)),p=new Uint8Array((await f.subtle.sign("HMAC",d,c)).slice(0,i>>3)),g;try{g=it(o,p)}catch(A){}if(!g)throw new k;let v;try{v=new Uint8Array(await f.subtle.decrypt({iv:n,name:"AES-CBC"},s,r))}catch(A){}if(!v)throw new k;return v}async function jt(e,t,r,n,o,a){let i;t instanceof Uint8Array?i=await f.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(I(t,e,"decrypt"),i=t);try{return new Uint8Array(await f.subtle.decrypt({additionalData:a,iv:n,name:"AES-GCM",tagLength:128},i,P(r,o)))}catch(s){throw new k}}var er=async(e,t,r,n,o,a)=>{if(!_(t)&&!(t instanceof Uint8Array))throw new TypeError(S(t,...h,"Uint8Array"));switch(Te(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&ee(t,parseInt(e.slice(-3),10)),Qt(e,t,r,n,o,a);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&ee(t,parseInt(e.slice(1,4),10)),jt(e,t,r,n,o,a);default:throw new l("Unsupported JWE Content Encryption Algorithm")}},De=er;var dt=async()=>{throw new l('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.')},pt=async()=>{throw new l('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.')};var tr=(...e)=>{let t=e.filter(Boolean);if(t.length===0||t.length===1)return!0;let r;for(let n of t){let o=Object.keys(n);if(!r||r.size===0){r=new Set(o);continue}for(let a of o){if(r.has(a))return!1;r.add(a)}}return!0},U=tr;function rr(e){return typeof e=="object"&&e!==null}function y(e){if(!rr(e)||Object.prototype.toString.call(e)!=="[object Object]")return!1;if(Object.getPrototypeOf(e)===null)return!0;let t=e;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}var nr=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]],te=nr;function ut(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function ft(e,t,r){if(_(e))return I(e,t,r),e;if(e instanceof Uint8Array)return f.subtle.importKey("raw",e,"AES-KW",!0,[r]);throw new TypeError(S(e,...h,"Uint8Array"))}var ue=async(e,t,r)=>{let n=await ft(t,e,"wrapKey");ut(n,e);let o=await f.subtle.importKey("raw",r,...te);return new Uint8Array(await f.subtle.wrapKey("raw",o,n,"AES-KW"))},fe=async(e,t,r)=>{let n=await ft(t,e,"unwrapKey");ut(n,e);let o=await f.subtle.unwrapKey("raw",r,n,"AES-KW",...te);return new Uint8Array(await f.subtle.exportKey("raw",o))};async function Oe(e,t,r,n,o=new Uint8Array(0),a=new Uint8Array(0)){if(!_(e))throw new TypeError(S(e,...h));if(I(e,"ECDH-ES"),!_(t))throw new TypeError(S(t,...h));I(t,"ECDH-ES","deriveBits","deriveKey");let i=P(He(w.encode(r)),He(o),He(a),Ce(n));if(!t.usages.includes("deriveBits"))throw new TypeError('ECDH-ES private key "usages" must include "deriveBits"');let s=new Uint8Array(await f.subtle.deriveBits({name:"ECDH",public:e},t,Math.ceil(parseInt(t.algorithm.namedCurve.slice(-3),10)/8)<<3));return nt(s,n,i)}async function lt(e){if(!_(e))throw new TypeError(S(e,...h));return f.subtle.generateKey(e.algorithm,!0,["deriveBits"])}function Re(e){if(!_(e))throw new TypeError(S(e,...h));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)}function Fe(e){if(!(e instanceof Uint8Array)||e.length<8)throw new u("PBES2 Salt Input must be 8 or more octets")}function or(e,t){if(e instanceof Uint8Array)return f.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(_(e))return I(e,t,"deriveBits","deriveKey"),e;throw new TypeError(S(e,...h,"Uint8Array"))}async function ht(e,t,r,n){Fe(e);let o=rt(t,e),a=parseInt(t.slice(13,16),10),i={hash:`SHA-${t.slice(8,11)}`,iterations:r,name:"PBKDF2",salt:o},s={length:a,name:"AES-KW"},d=await or(n,t);if(d.usages.includes("deriveBits"))return new Uint8Array(await f.subtle.deriveBits(i,d,a));if(d.usages.includes("deriveKey"))return f.subtle.deriveKey(i,d,s,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}var yt=async(e,t,r,n=Math.floor(Math.random()*2049)+2048,o=B(new Uint8Array(16)))=>{let a=await ht(o,e,n,t);return{encryptedKey:await ue(e.slice(-6),a,r),p2c:n,p2s:E(o)}},wt=async(e,t,r,n,o)=>{let a=await ht(o,e,n,t);return fe(e.slice(-6),a,r)};function re(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new l(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var z=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){let{modulusLength:r}=t.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};var Et=async(e,t,r)=>{if(!_(t))throw new TypeError(S(t,...h));if(I(t,e,"encrypt","wrapKey"),z(e,t),t.usages.includes("encrypt"))return new Uint8Array(await f.subtle.encrypt(re(e),t,r));if(t.usages.includes("wrapKey")){let n=await f.subtle.importKey("raw",r,...te);return new Uint8Array(await f.subtle.wrapKey("raw",n,t,re(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')},gt=async(e,t,r)=>{if(!_(t))throw new TypeError(S(t,...h));if(I(t,e,"decrypt","unwrapKey"),z(e,t),t.usages.includes("decrypt"))return new Uint8Array(await f.subtle.decrypt(re(e),t,r));if(t.usages.includes("unwrapKey")){let n=await f.subtle.unwrapKey("raw",r,t,re(e),...te);return new Uint8Array(await f.subtle.exportKey("raw",n))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')};function le(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new l(`Unsupported JWE Algorithm: ${e}`)}}var M=e=>B(new Uint8Array(le(e)>>3));var Ue=(e,t)=>{let r=(e.match(/.{1,64}/g)||[]).join(`
`);return`-----BEGIN ${t}-----
${r}
-----END ${t}-----`};var At=async(e,t,r)=>{if(!_(r))throw new TypeError(S(r,...h));if(!r.extractable)throw new TypeError("CryptoKey is not extractable");if(r.type!==e)throw new TypeError(`key is not a ${e} key`);return Ue(de(new Uint8Array(await f.subtle.exportKey(t,r))),`${e.toUpperCase()} KEY`)},bt=e=>At("public","spki",e),_t=e=>At("private","pkcs8",e),ne=(e,t,r=0)=>{r===0&&(t.unshift(t.length),t.unshift(6));let n=e.indexOf(t[0],r);if(n===-1)return!1;let o=e.subarray(n,n+t.length);return o.length!==t.length?!1:o.every((a,i)=>a===t[i])||ne(e,t,n+1)},St=e=>{switch(!0){case ne(e,[42,134,72,206,61,3,1,7]):return"P-256";case ne(e,[43,129,4,0,34]):return"P-384";case ne(e,[43,129,4,0,35]):return"P-521";case((D()||T())&&ne(e,[43,101,112])):return"Ed25519";case(T()&&ne(e,[43,101,113])):return"Ed448";default:throw new l("Invalid or unsupported EC Key Curve or OKP Key Sub Type")}},Kt=async(e,t,r,n,o)=>{var a;let i,s,d=new Uint8Array(atob(r.replace(e,"")).split("").map(p=>p.charCodeAt(0))),c=t==="spki";switch(n){case"PS256":case"PS384":case"PS512":i={name:"RSA-PSS",hash:`SHA-${n.slice(-3)}`},s=c?["verify"]:["sign"];break;case"RS256":case"RS384":case"RS512":i={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${n.slice(-3)}`},s=c?["verify"]:["sign"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":i={name:"RSA-OAEP",hash:`SHA-${parseInt(n.slice(-3),10)||1}`},s=c?["encrypt","wrapKey"]:["decrypt","unwrapKey"];break;case"ES256":i={name:"ECDSA",namedCurve:"P-256"},s=c?["verify"]:["sign"];break;case"ES384":i={name:"ECDSA",namedCurve:"P-384"},s=c?["verify"]:["sign"];break;case"ES512":i={name:"ECDSA",namedCurve:"P-521"},s=c?["verify"]:["sign"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":i={name:"ECDH",namedCurve:St(d)},s=c?[]:["deriveBits"];break;case((D()||T())&&"EdDSA"):let p=St(d).toUpperCase();i={name:`NODE-${p}`,namedCurve:`NODE-${p}`},s=c?["verify"]:["sign"];break;default:throw new l('Invalid or unsupported "alg" (Algorithm) value')}return f.subtle.importKey(t,d,i,(a=o==null?void 0:o.extractable)!==null&&a!==void 0?a:!1,s)},vt=(e,t,r)=>Kt(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g,"pkcs8",e,t,r),Ve=(e,t,r)=>Kt(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,"spki",e,t,r);function ar(e){let t,r;switch(e.kty){case"oct":{switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:`SHA-${e.alg.slice(-3)}`},r=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new l(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"},r=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"},r=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"},r=["deriveBits"];break;default:throw new l('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"RSA":{switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new l('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new l('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case((D()||T())&&"OKP"):if(e.alg!=="EdDSA")throw new l('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');switch(e.crv){case"Ed25519":t={name:"NODE-ED25519",namedCurve:"NODE-ED25519"},r=e.d?["sign"]:["verify"];break;case(T()&&"Ed448"):t={name:"NODE-ED448",namedCurve:"NODE-ED448"},r=e.d?["sign"]:["verify"];break;default:throw new l('Invalid or unsupported JWK "crv" (Subtype of Key Pair) Parameter value')}break;default:throw new l('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}var ir=async e=>{var t,r;let{algorithm:n,keyUsages:o}=ar(e),a=[n,(t=e.ext)!==null&&t!==void 0?t:!1,(r=e.key_ops)!==null&&r!==void 0?r:o];if(n.name==="PBKDF2")return f.subtle.importKey("raw",b(e.k),...a);let i={...e};return delete i.alg,f.subtle.importKey("jwk",i,...a)},ze=ir;function Ct(e){let t=[],r=0;for(;r<e.length;){let n=Ht(e.subarray(r));t.push(n),r+=n.byteLength}return t}function Ht(e){let t=0,r=e[0]&31;if(t++,r===31){for(r=0;e[t]>=128;)r=r*128+e[t]-128,t++;r=r*128+e[t]-128,t++}let n=0;if(e[t]<128)n=e[t],t++;else{let a=e[t]&127;t++,n=0;for(let i=0;i<a;i++)n=n*256+e[t],t++}if(n===128){for(n=0;e[t+n]!==0||e[t+n+1]!==0;)n++;let a=t+n+2;return{byteLength:a,contents:e.subarray(t,t+n),raw:e.subarray(0,a)}}let o=t+n;return{byteLength:o,contents:e.subarray(t,o),raw:e.subarray(0,o)}}function sr(e){let t=Ct(Ct(Ht(e).contents)[0].contents);return de(t[t[0].raw[0]===160?6:5].raw)}function cr(e){let t=e.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g,""),r=Le(t);return Ue(sr(r),"PUBLIC KEY")}async function dr(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN PUBLIC KEY-----")!==0)throw new TypeError('"spki" must be SPKI formatted string');return Ve(e,t,r)}async function pr(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN CERTIFICATE-----")!==0)throw new TypeError('"x509" must be X.509 formatted string');let n=cr(e);return Ve(n,t,r)}async function ur(e,t,r){if(typeof e!="string"||e.indexOf("-----BEGIN PRIVATE KEY-----")!==0)throw new TypeError('"pkcs8" must be PCKS8 formatted string');return vt(e,t,r)}async function Y(e,t,r){if(!y(e))throw new TypeError("JWK must be an object");if(t||(t=e.alg),typeof t!="string"||!t)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');switch(e.kty){case"oct":if(typeof e.k!="string"||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return r!=null||(r=e.ext!==!0),r?ze({...e,alg:t,ext:!1}):b(e.k);case"RSA":if(e.oth!==void 0)throw new l('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return ze({...e,alg:t});default:throw new l('Unsupported "kty" (Key Type) Parameter value')}}var fr=e=>{if(!(e instanceof Uint8Array)){if(!Ge(e))throw new TypeError(S(e,...h,"Uint8Array"));if(e.type!=="secret")throw new TypeError(`${h.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}},lr=(e,t)=>{if(!Ge(e))throw new TypeError(S(e,...h));if(e.type==="secret")throw new TypeError(`${h.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if(t==="sign"&&e.type==="public")throw new TypeError(`${h.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if(t==="decrypt"&&e.type==="public")throw new TypeError(`${h.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(e.algorithm&&t==="verify"&&e.type==="private")throw new TypeError(`${h.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(e.algorithm&&t==="encrypt"&&e.type==="private")throw new TypeError(`${h.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)},mr=(e,t,r)=>{e.startsWith("HS")||e==="dir"||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?fr(t):lr(t,r)},L=mr;async function hr(e,t,r,n,o){if(!(r instanceof Uint8Array))throw new TypeError(S(r,"Uint8Array"));let a=parseInt(e.slice(1,4),10),i=await f.subtle.importKey("raw",r.subarray(a>>3),"AES-CBC",!1,["encrypt"]),s=await f.subtle.importKey("raw",r.subarray(0,a>>3),{hash:`SHA-${a<<1}`,name:"HMAC"},!1,["sign"]),d=new Uint8Array(await f.subtle.encrypt({iv:n,name:"AES-CBC"},i,t)),c=P(o,n,d,ve(o.length<<3)),p=new Uint8Array((await f.subtle.sign("HMAC",s,c)).slice(0,a>>3));return{ciphertext:d,tag:p}}async function yr(e,t,r,n,o){let a;r instanceof Uint8Array?a=await f.subtle.importKey("raw",r,"AES-GCM",!1,["encrypt"]):(I(r,e,"encrypt"),a=r);let i=new Uint8Array(await f.subtle.encrypt({additionalData:o,iv:n,name:"AES-GCM",tagLength:128},a,t)),s=i.slice(-16);return{ciphertext:i.slice(0,-16),tag:s}}var wr=async(e,t,r,n,o)=>{if(!_(r)&&!(r instanceof Uint8Array))throw new TypeError(S(r,...h,"Uint8Array"));switch(Te(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return r instanceof Uint8Array&&ee(r,parseInt(e.slice(-3),10)),hr(e,t,r,n,o);case"A128GCM":case"A192GCM":case"A256GCM":return r instanceof Uint8Array&&ee(r,parseInt(e.slice(1,4),10)),yr(e,t,r,n,o);default:throw new l("Unsupported JWE Content Encryption Algorithm")}},me=wr;async function xt(e,t,r,n){let o=e.slice(0,7);n||(n=Je(o));let{ciphertext:a,tag:i}=await me(o,r,t,n,new Uint8Array(0));return{encryptedKey:a,iv:E(n),tag:E(i)}}async function Pt(e,t,r,n,o){let a=e.slice(0,7);return De(a,t,r,n,o,new Uint8Array(0))}async function Er(e,t,r,n){switch(L(e,t,"decrypt"),e){case"dir":{if(r!==void 0)throw new u("Encountered unexpected JWE Encrypted Key");return t}case"ECDH-ES":if(r!==void 0)throw new u("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!y(n.epk))throw new u('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!Re(t))throw new l("ECDH-ES with the provided key is not allowed or not supported by your javascript runtime");let o=await Y(n.epk,e),a,i;if(n.apu!==void 0){if(typeof n.apu!="string")throw new u('JOSE Header "apu" (Agreement PartyUInfo) invalid');a=b(n.apu)}if(n.apv!==void 0){if(typeof n.apv!="string")throw new u('JOSE Header "apv" (Agreement PartyVInfo) invalid');i=b(n.apv)}let s=await Oe(o,t,e==="ECDH-ES"?n.enc:e,e==="ECDH-ES"?le(n.enc):parseInt(e.slice(-5,-2),10),a,i);if(e==="ECDH-ES")return s;if(r===void 0)throw new u("JWE Encrypted Key missing");return fe(e.slice(-6),s,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(r===void 0)throw new u("JWE Encrypted Key missing");return gt(e,t,r)}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(r===void 0)throw new u("JWE Encrypted Key missing");if(typeof n.p2c!="number")throw new u('JOSE Header "p2c" (PBES2 Count) missing or invalid');if(typeof n.p2s!="string")throw new u('JOSE Header "p2s" (PBES2 Salt) missing or invalid');return wt(e,t,r,n.p2c,b(n.p2s))}case"A128KW":case"A192KW":case"A256KW":{if(r===void 0)throw new u("JWE Encrypted Key missing");return fe(e,t,r)}case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(r===void 0)throw new u("JWE Encrypted Key missing");if(typeof n.iv!="string")throw new u('JOSE Header "iv" (Initialization Vector) missing or invalid');if(typeof n.tag!="string")throw new u('JOSE Header "tag" (Authentication Tag) missing or invalid');let o=b(n.iv),a=b(n.tag);return Pt(e,t,r,o,a)}default:throw new l('Invalid or unsupported "alg" (JWE Algorithm) header value')}}var Wt=Er;function gr(e,t,r,n,o){if(o.crit!==void 0&&n.crit===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||n.crit===void 0)return new Set;if(!Array.isArray(n.crit)||n.crit.length===0||n.crit.some(i=>typeof i!="string"||i.length===0))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let a;r!==void 0?a=new Map([...Object.entries(r),...t.entries()]):a=t;for(let i of n.crit){if(!a.has(i))throw new l(`Extension Header Parameter "${i}" is not recognized`);if(o[i]===void 0)throw new e(`Extension Header Parameter "${i}" is missing`);if(a.get(i)&&n[i]===void 0)throw new e(`Extension Header Parameter "${i}" MUST be integrity protected`)}return new Set(n.crit)}var N=gr;var Sr=(e,t)=>{if(t!==void 0&&(!Array.isArray(t)||t.some(r=>typeof r!="string")))throw new TypeError(`"${e}" option must be an array of strings`);if(!!t)return new Set(t)},he=Sr;async function ye(e,t,r){var n;if(!y(e))throw new u("Flattened JWE must be an object");if(e.protected===void 0&&e.header===void 0&&e.unprotected===void 0)throw new u("JOSE Header missing");if(typeof e.iv!="string")throw new u("JWE Initialization Vector missing or incorrect type");if(typeof e.ciphertext!="string")throw new u("JWE Ciphertext missing or incorrect type");if(typeof e.tag!="string")throw new u("JWE Authentication Tag missing or incorrect type");if(e.protected!==void 0&&typeof e.protected!="string")throw new u("JWE Protected Header incorrect type");if(e.encrypted_key!==void 0&&typeof e.encrypted_key!="string")throw new u("JWE Encrypted Key incorrect type");if(e.aad!==void 0&&typeof e.aad!="string")throw new u("JWE AAD incorrect type");if(e.header!==void 0&&!y(e.header))throw new u("JWE Shared Unprotected Header incorrect type");if(e.unprotected!==void 0&&!y(e.unprotected))throw new u("JWE Per-Recipient Unprotected Header incorrect type");let o;if(e.protected){let _e=b(e.protected);try{o=JSON.parse(K.decode(_e))}catch(Vr){throw new u("JWE Protected Header is invalid")}}if(!U(o,e.header,e.unprotected))throw new u("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");let a={...o,...e.header,...e.unprotected};if(N(u,new Map,r==null?void 0:r.crit,o,a),a.zip!==void 0){if(!o||!o.zip)throw new u('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if(a.zip!=="DEF")throw new l('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}let{alg:i,enc:s}=a;if(typeof i!="string"||!i)throw new u("missing JWE Algorithm (alg) in JWE Header");if(typeof s!="string"||!s)throw new u("missing JWE Encryption Algorithm (enc) in JWE Header");let d=r&&he("keyManagementAlgorithms",r.keyManagementAlgorithms),c=r&&he("contentEncryptionAlgorithms",r.contentEncryptionAlgorithms);if(d&&!d.has(i))throw new F('"alg" (Algorithm) Header Parameter not allowed');if(c&&!c.has(s))throw new F('"enc" (Encryption Algorithm) Header Parameter not allowed');let p;e.encrypted_key!==void 0&&(p=b(e.encrypted_key));let g=!1;typeof t=="function"&&(t=await t(o,e),g=!0);let v;try{v=await Wt(i,t,p,a)}catch(_e){if(_e instanceof TypeError)throw _e;v=M(s)}let A=b(e.iv),x=b(e.tag),O=w.encode((n=e.protected)!==null&&n!==void 0?n:""),G;e.aad!==void 0?G=P(O,w.encode("."),w.encode(e.aad)):G=O;let be=await De(s,v,b(e.ciphertext),A,x,G);a.zip==="DEF"&&(be=await((r==null?void 0:r.inflateRaw)||dt)(be));let Z={plaintext:be};return e.protected!==void 0&&(Z.protectedHeader=o),e.aad!==void 0&&(Z.additionalAuthenticatedData=b(e.aad)),e.unprotected!==void 0&&(Z.sharedUnprotectedHeader=e.unprotected),e.header!==void 0&&(Z.unprotectedHeader=e.header),g?{...Z,key:t}:Z}async function Ye(e,t,r){if(e instanceof Uint8Array&&(e=K.decode(e)),typeof e!="string")throw new u("Compact JWE must be a string or Uint8Array");let{0:n,1:o,2:a,3:i,4:s,length:d}=e.split(".");if(d!==5)throw new u("Invalid Compact JWE");let c=await ye({ciphertext:i,iv:a||void 0,protected:n||void 0,tag:s||void 0,encrypted_key:o||void 0},t,r),p={plaintext:c.plaintext,protectedHeader:c.protectedHeader};return typeof t=="function"?{...p,key:c.key}:p}async function Ar(e,t,r){if(!y(e))throw new u("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(y))throw new u("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new u("JWE Recipients has no members");for(let n of e.recipients)try{return await ye({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:n.encrypted_key,header:n.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,r)}catch(o){}throw new k}var br=async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:E(e)};if(!_(e))throw new TypeError(S(e,...h,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");let{ext:t,key_ops:r,alg:n,use:o,...a}=await f.subtle.exportKey("jwk",e);return a},Jt=br;async function _r(e){return bt(e)}async function Kr(e){return _t(e)}async function Xe(e){return Jt(e)}async function vr(e,t,r,n,o={}){let a,i,s;switch(L(e,r,"encrypt"),e){case"dir":{s=r;break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!Re(r))throw new l("ECDH-ES with the provided key is not allowed or not supported by your javascript runtime");let{apu:d,apv:c}=o,{epk:p}=o;p||(p=(await lt(r)).privateKey);let{x:g,y:v,crv:A,kty:x}=await Xe(p),O=await Oe(r,p,e==="ECDH-ES"?t:e,e==="ECDH-ES"?le(t):parseInt(e.slice(-5,-2),10),d,c);if(i={epk:{x:g,crv:A,kty:x}},x==="EC"&&(i.epk.y=v),d&&(i.apu=E(d)),c&&(i.apv=E(c)),e==="ECDH-ES"){s=O;break}s=n||M(t);let G=e.slice(-6);a=await ue(G,O,s);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{s=n||M(t),a=await Et(e,r,s);break}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{s=n||M(t);let{p2c:d,p2s:c}=o;({encryptedKey:a,...i}=await yt(e,r,s,d,c));break}case"A128KW":case"A192KW":case"A256KW":{s=n||M(t),a=await ue(e,r,s);break}case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{s=n||M(t);let{iv:d}=o;({encryptedKey:a,...i}=await xt(e,r,s,d));break}default:throw new l('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:s,encryptedKey:a,parameters:i}}var Me=vr;var qe=Symbol(),X=class{constructor(t){if(!(t instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=t}setKeyManagementParameters(t){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=t,this}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setSharedUnprotectedHeader(t){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=t,this}setUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}setAdditionalAuthenticatedData(t){return this._aad=t,this}setContentEncryptionKey(t){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=t,this}setInitializationVector(t){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=t,this}async encrypt(t,r){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new u("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!U(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new u("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");let n={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(N(u,new Map,r==null?void 0:r.crit,this._protectedHeader,n),n.zip!==void 0){if(!this._protectedHeader||!this._protectedHeader.zip)throw new u('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if(n.zip!=="DEF")throw new l('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}let{alg:o,enc:a}=n;if(typeof o!="string"||!o)throw new u('JWE "alg" (Algorithm) Header Parameter missing or invalid');if(typeof a!="string"||!a)throw new u('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let i;if(o==="dir"){if(this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption")}else if(o==="ECDH-ES"&&this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");let s;{let x;({cek:s,encryptedKey:i,parameters:x}=await Me(o,a,t,this._cek,this._keyManagementParameters)),x&&(r&&qe in r?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...x}:this.setUnprotectedHeader(x):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...x}:this.setProtectedHeader(x))}this._iv||(this._iv=Je(a));let d,c,p;this._protectedHeader?c=w.encode(E(JSON.stringify(this._protectedHeader))):c=w.encode(""),this._aad?(p=E(this._aad),d=P(c,w.encode("."),w.encode(p))):d=c;let g,v;if(n.zip==="DEF"){let x=await((r==null?void 0:r.deflateRaw)||pt)(this._plaintext);({ciphertext:g,tag:v}=await me(a,x,s,this._iv,d))}else({ciphertext:g,tag:v}=await me(a,this._plaintext,s,this._iv,d));let A={ciphertext:E(g),iv:E(this._iv),tag:E(v)};return i&&(A.encrypted_key=E(i)),p&&(A.aad=p),this._protectedHeader&&(A.protected=K.decode(c)),this._sharedUnprotectedHeader&&(A.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(A.header=this._unprotectedHeader),A}};var Tt=class{constructor(t,r,n){this.parent=t,this.key=r,this.options=n}setUnprotectedHeader(t){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=t,this}addRecipient(...t){return this.parent.addRecipient(...t)}encrypt(...t){return this.parent.encrypt(...t)}done(){return this.parent}},It=class{constructor(t){this._recipients=[],this._plaintext=t}addRecipient(t,r){let n=new Tt(this,t,{crit:r==null?void 0:r.crit});return this._recipients.push(n),n}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setSharedUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}setAdditionalAuthenticatedData(t){return this._aad=t,this}async encrypt(t){var r,n,o;if(!this._recipients.length)throw new u("at least one recipient must be added");if(t={deflateRaw:t==null?void 0:t.deflateRaw},this._recipients.length===1){let[d]=this._recipients,c=await new X(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(d.unprotectedHeader).encrypt(d.key,{...d.options,...t}),p={ciphertext:c.ciphertext,iv:c.iv,recipients:[{}],tag:c.tag};return c.aad&&(p.aad=c.aad),c.protected&&(p.protected=c.protected),c.unprotected&&(p.unprotected=c.unprotected),c.encrypted_key&&(p.recipients[0].encrypted_key=c.encrypted_key),c.header&&(p.recipients[0].header=c.header),p}let a;for(let d=0;d<this._recipients.length;d++){let c=this._recipients[d];if(!U(this._protectedHeader,this._unprotectedHeader,c.unprotectedHeader))throw new u("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");let p={...this._protectedHeader,...this._unprotectedHeader,...c.unprotectedHeader},{alg:g}=p;if(typeof g!="string"||!g)throw new u('JWE "alg" (Algorithm) Header Parameter missing or invalid');if(g==="dir"||g==="ECDH-ES")throw new u('"dir" and "ECDH-ES" alg may only be used with a single recipient');if(typeof p.enc!="string"||!p.enc)throw new u('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(!a)a=p.enc;else if(a!==p.enc)throw new u('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');if(N(u,new Map,c.options.crit,this._protectedHeader,p),p.zip!==void 0&&(!this._protectedHeader||!this._protectedHeader.zip))throw new u('JWE "zip" (Compression Algorithm) Header MUST be integrity protected')}let i=M(a),s={ciphertext:"",iv:"",recipients:[],tag:""};for(let d=0;d<this._recipients.length;d++){let c=this._recipients[d],p={};if(s.recipients.push(p),d===0){let A=await new X(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(i).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(c.unprotectedHeader).encrypt(c.key,{...c.options,...t,[qe]:!0});s.ciphertext=A.ciphertext,s.iv=A.iv,s.tag=A.tag,A.aad&&(s.aad=A.aad),A.protected&&(s.protected=A.protected),A.unprotected&&(s.unprotected=A.unprotected),p.encrypted_key=A.encrypted_key,A.header&&(p.header=A.header);continue}let{encryptedKey:g,parameters:v}=await Me(((r=c.unprotectedHeader)===null||r===void 0?void 0:r.alg)||((n=this._protectedHeader)===null||n===void 0?void 0:n.alg)||((o=this._unprotectedHeader)===null||o===void 0?void 0:o.alg),a,c.key,i);p.encrypted_key=E(g),(c.unprotectedHeader||v)&&(p.header={...c.unprotectedHeader,...v})}return s}};function we(e,t){let r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case((D()||T())&&"EdDSA"):let{namedCurve:n}=t;return{name:n,namedCurve:n};default:throw new l(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function Ee(e,t,r){if(_(t))return ct(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(S(t,...h));return f.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(S(t,...h,"Uint8Array"))}var Cr=async(e,t,r,n)=>{let o=await Ee(e,t,"verify");z(e,o);let a=we(e,o.algorithm);try{return await f.subtle.verify(a,o,r,n)}catch(i){return!1}},Dt=Cr;async function ge(e,t,r){var n;if(!y(e))throw new m("Flattened JWS must be an object");if(e.protected===void 0&&e.header===void 0)throw new m('Flattened JWS must have either of the "protected" or "header" members');if(e.protected!==void 0&&typeof e.protected!="string")throw new m("JWS Protected Header incorrect type");if(e.payload===void 0)throw new m("JWS Payload missing");if(typeof e.signature!="string")throw new m("JWS Signature missing or incorrect type");if(e.header!==void 0&&!y(e.header))throw new m("JWS Unprotected Header incorrect type");let o={};if(e.protected){let G=b(e.protected);try{o=JSON.parse(K.decode(G))}catch(be){throw new m("JWS Protected Header is invalid")}}if(!U(o,e.header))throw new m("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");let a={...o,...e.header},i=N(m,new Map([["b64",!0]]),r==null?void 0:r.crit,o,a),s=!0;if(i.has("b64")&&(s=o.b64,typeof s!="boolean"))throw new m('The "b64" (base64url-encode payload) Header Parameter must be a boolean');let{alg:d}=a;if(typeof d!="string"||!d)throw new m('JWS "alg" (Algorithm) Header Parameter missing or invalid');let c=r&&he("algorithms",r.algorithms);if(c&&!c.has(d))throw new F('"alg" (Algorithm) Header Parameter not allowed');if(s){if(typeof e.payload!="string")throw new m("JWS Payload must be a string")}else if(typeof e.payload!="string"&&!(e.payload instanceof Uint8Array))throw new m("JWS Payload must be a string or an Uint8Array instance");let p=!1;typeof t=="function"&&(t=await t(o,e),p=!0),L(d,t,"verify");let g=P(w.encode((n=e.protected)!==null&&n!==void 0?n:""),w.encode("."),typeof e.payload=="string"?w.encode(e.payload):e.payload),v=b(e.signature);if(!await Dt(d,t,v,g))throw new j;let x;s?x=b(e.payload):typeof e.payload=="string"?x=w.encode(e.payload):x=e.payload;let O={payload:x};return e.protected!==void 0&&(O.protectedHeader=o),e.header!==void 0&&(O.unprotectedHeader=e.header),p?{...O,key:t}:O}async function Ze(e,t,r){if(e instanceof Uint8Array&&(e=K.decode(e)),typeof e!="string")throw new m("Compact JWS must be a string or Uint8Array");let{0:n,1:o,2:a,length:i}=e.split(".");if(i!==3)throw new m("Invalid Compact JWS");let s=await ge({payload:o,protected:n,signature:a},t,r),d={payload:s.payload,protectedHeader:s.protectedHeader};return typeof t=="function"?{...d,key:s.key}:d}async function Hr(e,t,r){if(!y(e))throw new m("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(y))throw new m("JWS Signatures missing or incorrect type");for(let n of e.signatures)try{return await ge({header:n.header,payload:e.payload,protected:n.protected,signature:n.signature},t,r)}catch(o){}throw new j}var oe=e=>Math.floor(e.getTime()/1e3);var xr=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i,ae=e=>{let t=xr.exec(e);if(!t)throw new TypeError("Invalid time period format");let r=parseFloat(t[1]);switch(t[2].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":return Math.round(r);case"minute":case"minutes":case"min":case"mins":case"m":return Math.round(r*60);case"hour":case"hours":case"hr":case"hrs":case"h":return Math.round(r*3600);case"day":case"days":case"d":return Math.round(r*86400);case"week":case"weeks":case"w":return Math.round(r*604800);default:return Math.round(r*31557600)}};var Ot=e=>e.toLowerCase().replace(/^application\//,""),Pr=(e,t)=>typeof e=="string"?t.includes(e):Array.isArray(e)?t.some(Set.prototype.has.bind(new Set(e))):!1,ie=(e,t,r={})=>{let{typ:n}=r;if(n&&(typeof e.typ!="string"||Ot(e.typ)!==Ot(n)))throw new J('unexpected "typ" JWT header value',"typ","check_failed");let o;try{o=JSON.parse(K.decode(t))}catch(g){}if(!y(o))throw new C("JWT Claims Set must be a top-level JSON object");let{issuer:a}=r;if(a&&!(Array.isArray(a)?a:[a]).includes(o.iss))throw new J('unexpected "iss" claim value',"iss","check_failed");let{subject:i}=r;if(i&&o.sub!==i)throw new J('unexpected "sub" claim value',"sub","check_failed");let{audience:s}=r;if(s&&!Pr(o.aud,typeof s=="string"?[s]:s))throw new J('unexpected "aud" claim value',"aud","check_failed");let d;switch(typeof r.clockTolerance){case"string":d=ae(r.clockTolerance);break;case"number":d=r.clockTolerance;break;case"undefined":d=0;break;default:throw new TypeError("Invalid clockTolerance option type")}let{currentDate:c}=r,p=oe(c||new Date);if(o.iat!==void 0||r.maxTokenAge){if(typeof o.iat!="number")throw new J('"iat" claim must be a number',"iat","invalid");if(o.exp===void 0&&o.iat>p+d)throw new J('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}if(o.nbf!==void 0){if(typeof o.nbf!="number")throw new J('"nbf" claim must be a number',"nbf","invalid");if(o.nbf>p+d)throw new J('"nbf" claim timestamp check failed',"nbf","check_failed")}if(o.exp!==void 0){if(typeof o.exp!="number")throw new J('"exp" claim must be a number',"exp","invalid");if(o.exp<=p-d)throw new pe('"exp" claim timestamp check failed',"exp","check_failed")}if(r.maxTokenAge){let g=p-o.iat,v=typeof r.maxTokenAge=="number"?r.maxTokenAge:ae(r.maxTokenAge);if(g-d>v)throw new pe('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(g<0-d)throw new J('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return o};async function Wr(e,t,r){var n;let o=await Ze(e,t,r);if(((n=o.protectedHeader.crit)===null||n===void 0?void 0:n.includes("b64"))&&o.protectedHeader.b64===!1)throw new C("JWTs MUST NOT use unencoded payload");let i={payload:ie(o.protectedHeader,o.payload,r),protectedHeader:o.protectedHeader};return typeof t=="function"?{...i,key:o.key}:i}async function Jr(e,t,r){let n=await Ye(e,t,r),o=ie(n.protectedHeader,n.plaintext,r),{protectedHeader:a}=n;if(a.iss!==void 0&&a.iss!==o.iss)throw new J('replicated "iss" claim header parameter mismatch',"iss","mismatch");if(a.sub!==void 0&&a.sub!==o.sub)throw new J('replicated "sub" claim header parameter mismatch',"sub","mismatch");if(a.aud!==void 0&&JSON.stringify(a.aud)!==JSON.stringify(o.aud))throw new J('replicated "aud" claim header parameter mismatch',"aud","mismatch");let i={payload:o,protectedHeader:a};return typeof t=="function"?{...i,key:n.key}:i}var Ne=class{constructor(t){this._flattened=new X(t)}setContentEncryptionKey(t){return this._flattened.setContentEncryptionKey(t),this}setInitializationVector(t){return this._flattened.setInitializationVector(t),this}setProtectedHeader(t){return this._flattened.setProtectedHeader(t),this}setKeyManagementParameters(t){return this._flattened.setKeyManagementParameters(t),this}async encrypt(t,r){let n=await this._flattened.encrypt(t,r);return[n.protected,n.encrypted_key,n.iv,n.ciphertext,n.tag].join(".")}};var Tr=async(e,t,r)=>{let n=await Ee(e,t,"sign");z(e,n);let o=await f.subtle.sign(we(e,n.algorithm),n,r);return new Uint8Array(o)},Rt=Tr;var se=class{constructor(t){if(!(t instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=t}setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setUnprotectedHeader(t){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=t,this}async sign(t,r){if(!this._protectedHeader&&!this._unprotectedHeader)throw new m("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!U(this._protectedHeader,this._unprotectedHeader))throw new m("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");let n={...this._protectedHeader,...this._unprotectedHeader},o=N(m,new Map([["b64",!0]]),r==null?void 0:r.crit,this._protectedHeader,n),a=!0;if(o.has("b64")&&(a=this._protectedHeader.b64,typeof a!="boolean"))throw new m('The "b64" (base64url-encode payload) Header Parameter must be a boolean');let{alg:i}=n;if(typeof i!="string"||!i)throw new m('JWS "alg" (Algorithm) Header Parameter missing or invalid');L(i,t,"sign");let s=this._payload;a&&(s=w.encode(E(s)));let d;this._protectedHeader?d=w.encode(E(JSON.stringify(this._protectedHeader))):d=w.encode("");let c=P(d,w.encode("."),s),p=await Rt(i,t,c),g={signature:E(p),payload:""};return a&&(g.payload=K.decode(s)),this._unprotectedHeader&&(g.header=this._unprotectedHeader),this._protectedHeader&&(g.protected=K.decode(d)),g}};var ke=class{constructor(t){this._flattened=new se(t)}setProtectedHeader(t){return this._flattened.setProtectedHeader(t),this}async sign(t,r){let n=await this._flattened.sign(t,r);if(n.payload===void 0)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${n.protected}.${n.payload}.${n.signature}`}};var Ut=class{constructor(t,r,n){this.parent=t,this.key=r,this.options=n}setProtectedHeader(t){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=t,this}setUnprotectedHeader(t){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=t,this}addSignature(...t){return this.parent.addSignature(...t)}sign(...t){return this.parent.sign(...t)}done(){return this.parent}},Mt=class{constructor(t){this._signatures=[],this._payload=t}addSignature(t,r){let n=new Ut(this,t,r);return this._signatures.push(n),n}async sign(){if(!this._signatures.length)throw new m("at least one signature must be added");let t={signatures:[],payload:""};for(let r=0;r<this._signatures.length;r++){let n=this._signatures[r],o=new se(this._payload);o.setProtectedHeader(n.protectedHeader),o.setUnprotectedHeader(n.unprotectedHeader);let{payload:a,...i}=await o.sign(n.key,n.options);if(r===0)t.payload=a;else if(t.payload!==a)throw new m("inconsistent use of JWS Unencoded Payload Option (RFC7797)");t.signatures.push(i)}return t}};var q=class{constructor(t){if(!y(t))throw new TypeError("JWT Claims Set MUST be an object");this._payload=t}setIssuer(t){return this._payload={...this._payload,iss:t},this}setSubject(t){return this._payload={...this._payload,sub:t},this}setAudience(t){return this._payload={...this._payload,aud:t},this}setJti(t){return this._payload={...this._payload,jti:t},this}setNotBefore(t){return typeof t=="number"?this._payload={...this._payload,nbf:t}:this._payload={...this._payload,nbf:oe(new Date)+ae(t)},this}setExpirationTime(t){return typeof t=="number"?this._payload={...this._payload,exp:t}:this._payload={...this._payload,exp:oe(new Date)+ae(t)},this}setIssuedAt(t){return typeof t=="undefined"?this._payload={...this._payload,iat:oe(new Date)}:this._payload={...this._payload,iat:t},this}};var Nt=class extends q{setProtectedHeader(t){return this._protectedHeader=t,this}async sign(t,r){var n;let o=new ke(w.encode(JSON.stringify(this._payload)));if(o.setProtectedHeader(this._protectedHeader),Array.isArray((n=this._protectedHeader)===null||n===void 0?void 0:n.crit)&&this._protectedHeader.crit.includes("b64")&&this._protectedHeader.b64===!1)throw new C("JWTs MUST NOT use unencoded payload");return o.sign(t,r)}};var kt=class extends q{setProtectedHeader(t){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=t,this}setKeyManagementParameters(t){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=t,this}setContentEncryptionKey(t){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=t,this}setInitializationVector(t){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=t,this}replicateIssuerAsHeader(){return this._replicateIssuerAsHeader=!0,this}replicateSubjectAsHeader(){return this._replicateSubjectAsHeader=!0,this}replicateAudienceAsHeader(){return this._replicateAudienceAsHeader=!0,this}async encrypt(t,r){let n=new Ne(w.encode(JSON.stringify(this._payload)));return this._replicateIssuerAsHeader&&(this._protectedHeader={...this._protectedHeader,iss:this._payload.iss}),this._replicateSubjectAsHeader&&(this._protectedHeader={...this._protectedHeader,sub:this._payload.sub}),this._replicateAudienceAsHeader&&(this._protectedHeader={...this._protectedHeader,aud:this._payload.aud}),n.setProtectedHeader(this._protectedHeader),this._iv&&n.setInitializationVector(this._iv),this._cek&&n.setContentEncryptionKey(this._cek),this._keyManagementParameters&&n.setKeyManagementParameters(this._keyManagementParameters),n.encrypt(t,r)}};var $=(e,t)=>{if(typeof e!="string"||!e)throw new xe(`${t} missing or invalid`)};async function Ir(e,t="sha256"){if(!y(e))throw new TypeError("JWK must be an object");if(t!=="sha256"&&t!=="sha384"&&t!=="sha512")throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');let r;switch(e.kty){case"EC":$(e.crv,'"crv" (Curve) Parameter'),$(e.x,'"x" (X Coordinate) Parameter'),$(e.y,'"y" (Y Coordinate) Parameter'),r={crv:e.crv,kty:e.kty,x:e.x,y:e.y};break;case"OKP":$(e.crv,'"crv" (Subtype of Key Pair) Parameter'),$(e.x,'"x" (Public Key) Parameter'),r={crv:e.crv,kty:e.kty,x:e.x};break;case"RSA":$(e.e,'"e" (Exponent) Parameter'),$(e.n,'"n" (Modulus) Parameter'),r={e:e.e,kty:e.kty,n:e.n};break;case"oct":$(e.k,'"k" (Key Value) Parameter'),r={k:e.k,kty:e.kty};break;default:throw new l('"kty" (Key Type) Parameter missing or unsupported')}let n=w.encode(JSON.stringify(r));return E(await ce(t,n))}async function Dr(e,t){let r={...e,...t.header};if(!y(r.jwk))throw new m('"jwk" (JSON Web Key) Header Parameter must be a JSON object');let n=await Y({...r.jwk,ext:!0},r.alg,!0);if(n instanceof Uint8Array||n.type!=="public")throw new m('"jwk" (JSON Web Key) Header Parameter must be a public key');return n}function Or(e){switch(typeof e=="string"&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new l('Unsupported "alg" value for a JSON Web Key Set')}}function Qe(e){return e&&typeof e=="object"&&Array.isArray(e.keys)&&e.keys.every(Rr)}function Rr(e){return y(e)}function Ur(e){return typeof structuredClone=="function"?structuredClone(e):JSON.parse(JSON.stringify(e))}var Se=class{constructor(t){if(this._cached=new WeakMap,!Qe(t))throw new V("JSON Web Key Set malformed");this._jwks=Ur(t)}async getKey(t,r){let{alg:n,kid:o}={...t,...r.header},a=this._jwks.keys.filter(c=>{let p=c.kty===Or(n);if(p&&typeof o=="string"&&(p=o===c.kid),p&&typeof c.alg=="string"&&(p=n===c.alg),p&&typeof c.use=="string"&&(p=c.use==="sig"),p&&Array.isArray(c.key_ops)&&(p=c.key_ops.includes("verify")),p&&n==="EdDSA"&&(p=c.crv==="Ed25519"||c.crv==="Ed448"),p)switch(n){case"ES256":p=c.crv==="P-256";break;case"ES256K":p=c.crv==="secp256k1";break;case"ES384":p=c.crv==="P-384";break;case"ES512":p=c.crv==="P-521";break}return p}),{0:i,length:s}=a;if(s===0)throw new Q;if(s!==1)throw new Pe;let d=this._cached.get(i)||this._cached.set(i,{}).get(i);if(d[n]===void 0){let c=await Y({...i,ext:!0},n);if(c instanceof Uint8Array||c.type!=="public")throw new V("JSON Web Key Set members must be public keys");d[n]=c}return d[n]}};function Mr(e){return Se.prototype.getKey.bind(new Se(e))}var Nr=async(e,t)=>{let r,n,o=!1;typeof AbortController=="function"&&(r=new AbortController,n=setTimeout(()=>{o=!0,r.abort()},t));let a=await fetch(e.href,{signal:r?r.signal:void 0,redirect:"manual"}).catch(i=>{throw o?new We:i});if(n!==void 0&&clearTimeout(n),a.status!==200)throw new H("Expected 200 OK from the JSON Web Key Set HTTP response");try{return await a.json()}catch(i){throw new H("Failed to parse the JSON Web Key Set HTTP response as JSON")}},Bt=Nr;var je=class extends Se{constructor(t,r){super({keys:[]});if(this._jwks=void 0,!(t instanceof URL))throw new TypeError("url must be an instance of URL");this._url=new URL(t.href),this._options={agent:r==null?void 0:r.agent},this._timeoutDuration=typeof(r==null?void 0:r.timeoutDuration)=="number"?r==null?void 0:r.timeoutDuration:5e3,this._cooldownDuration=typeof(r==null?void 0:r.cooldownDuration)=="number"?r==null?void 0:r.cooldownDuration:3e4}coolingDown(){return this._cooldownStarted?Date.now()<this._cooldownStarted+this._cooldownDuration:!1}async getKey(t,r){this._jwks||await this.reload();try{return await super.getKey(t,r)}catch(n){if(n instanceof Q&&this.coolingDown()===!1)return await this.reload(),super.getKey(t,r);throw n}}async reload(){if(this._pendingFetch&&D())return new Promise(t=>{let r=()=>{this._pendingFetch===void 0?t():setTimeout(r,5)};r()});this._pendingFetch||(this._pendingFetch=Bt(this._url,this._timeoutDuration,this._options).then(t=>{if(!Qe(t))throw new V("JSON Web Key Set malformed");this._jwks={keys:t.keys},this._cooldownStarted=Date.now(),this._pendingFetch=void 0}).catch(t=>{throw this._pendingFetch=void 0,t})),await this._pendingFetch}};function kr(e,t){return je.prototype.getKey.bind(new je(e,t))}var Lt=class extends q{encode(){let t=E(JSON.stringify({alg:"none"})),r=E(JSON.stringify(this._payload));return`${t}.${r}.`}static decode(t,r){if(typeof t!="string")throw new C("Unsecured JWT must be a string");let{0:n,1:o,2:a,length:i}=t.split(".");if(i!==3||a!=="")throw new C("Invalid Unsecured JWT");let s;try{if(s=JSON.parse(K.decode(b(n))),s.alg!=="none")throw new Error}catch(c){throw new C("Invalid Unsecured JWT")}return{payload:ie(s,b(o),r),header:s}}};var $t={};tt($t,{decode:()=>Ae,encode:()=>Br});var Br=E,Ae=b;function Lr(e){let t;if(typeof e=="string"){let r=e.split(".");(r.length===3||r.length===5)&&([t]=r)}else if(typeof e=="object"&&e)if("protected"in e)t=e.protected;else throw new TypeError("Token does not contain a Protected Header");try{if(typeof t!="string"||!t)throw new Error;let r=JSON.parse(K.decode(Ae(t)));if(!y(r))throw new Error;return r}catch(r){throw new TypeError("Invalid Token or Protected Header formatting")}}function $r(e){if(typeof e!="string")throw new C("JWTs must use Compact JWS serialization, JWT must be a string");let{1:t,length:r}=e.split(".");if(r===5)throw new C("Only JWTs using Compact JWS serialization can be decoded");if(r!==3)throw new C("Invalid JWT");if(!t)throw new C("JWTs must contain a payload");let n;try{n=Ae(t)}catch(a){throw new C("Failed to parse the base64url encoded payload")}let o;try{o=JSON.parse(K.decode(n))}catch(a){throw new C("Failed to parse the decoded payload as JSON")}if(!y(o))throw new C("Invalid JWT Claims Set");return o}async function Gt(e,t){var r;let n,o,a;switch(e){case"HS256":case"HS384":case"HS512":n=parseInt(e.slice(-3),10),o={name:"HMAC",hash:`SHA-${n}`,length:n},a=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return n=parseInt(e.slice(-3),10),B(new Uint8Array(n>>3));case"A128KW":case"A192KW":case"A256KW":n=parseInt(e.slice(1,4),10),o={name:"AES-KW",length:n},a=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":n=parseInt(e.slice(1,4),10),o={name:"AES-GCM",length:n},a=["encrypt","decrypt"];break;default:throw new l('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return f.subtle.generateKey(o,(r=t==null?void 0:t.extractable)!==null&&r!==void 0?r:!1,a)}function et(e){var t;let r=(t=e==null?void 0:e.modulusLength)!==null&&t!==void 0?t:2048;if(typeof r!="number"||r<2048)throw new l("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return r}async function Ft(e,t){var r,n;let o,a;switch(e){case"PS256":case"PS384":case"PS512":o={name:"RSA-PSS",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:et(t)},a=["sign","verify"];break;case"RS256":case"RS384":case"RS512":o={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:et(t)},a=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":o={name:"RSA-OAEP",hash:`SHA-${parseInt(e.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:et(t)},a=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":o={name:"ECDSA",namedCurve:"P-256"},a=["sign","verify"];break;case"ES384":o={name:"ECDSA",namedCurve:"P-384"},a=["sign","verify"];break;case"ES512":o={name:"ECDSA",namedCurve:"P-521"},a=["sign","verify"];break;case((D()||T())&&"EdDSA"):switch(t==null?void 0:t.crv){case void 0:case"Ed25519":o={name:"NODE-ED25519",namedCurve:"NODE-ED25519"},a=["sign","verify"];break;case(T()&&"Ed448"):o={name:"NODE-ED448",namedCurve:"NODE-ED448"},a=["sign","verify"];break;default:throw new l("Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448")}break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":o={name:"ECDH",namedCurve:(r=t==null?void 0:t.crv)!==null&&r!==void 0?r:"P-256"},a=["deriveKey","deriveBits"];break;default:throw new l('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return f.subtle.generateKey(o,(n=t==null?void 0:t.extractable)!==null&&n!==void 0?n:!1,a)}async function Gr(e,t){return Ft(e,t)}async function Fr(e,t){return Gt(e,t)}export{Ne as CompactEncrypt,ke as CompactSign,Dr as EmbeddedJWK,kt as EncryptJWT,X as FlattenedEncrypt,se as FlattenedSign,It as GeneralEncrypt,Mt as GeneralSign,Nt as SignJWT,Lt as UnsecuredJWT,$t as base64url,Ir as calculateJwkThumbprint,Ye as compactDecrypt,Ze as compactVerify,Mr as createLocalJWKSet,kr as createRemoteJWKSet,$r as decodeJwt,Lr as decodeProtectedHeader,at as errors,Xe as exportJWK,Kr as exportPKCS8,_r as exportSPKI,ye as flattenedDecrypt,ge as flattenedVerify,Ar as generalDecrypt,Hr as generalVerify,Gr as generateKeyPair,Fr as generateSecret,Y as importJWK,ur as importPKCS8,dr as importSPKI,pr as importX509,Jr as jwtDecrypt,Wr as jwtVerify};
